LLFS: The Little Log File System. Goals of this assignment 1. Manipulate a simulated disk, and format that disk with your version of the Little Log File System (LLFS) [20 marks].2. Modify LLFS to support: a. reading and writing of files in the root directory [20 marks] b. creation of sub-directories [10 marks] c. reading and writing of files in any directory [15 marks] d. deletion of files and directories [10 marks]3. Make LLFS robust, so that the file system is less likely to be corrupted if the machine it is running on crashes [15 marks].4. Submit test files used to exercise functionality [10 marks].Specifics of the code: In a directory called /disk, you will create a virtual disk environment, and in a directory called /io, you will create a program called File.c. This will be the basis for your filesystem. In a directory called /apps, build your test code as apps/test01.c to test simple functionality, such as see how blocks are read/written to a disk. I/O happens in one-block chunks. Write code in apps/test02.c to demonstrate how disks are created and how disks are mounted.
General ideas and instructions: The code in /disk will act as a library for a simulated disk, and your version of LLFS will be built using this library. The disk library will just use a simple file, named “vdisk” in the directory from which you run your test programs. This file should be about 2 megabytes in size. The contents of vdisk are wiped clean when the disk is explicitly formatted via a call to InitLLFS. The idea is that to treat this file as though it were a raw disk – you can run a program which uses LLFS to write a file to the simulated disk, and then run another program that reads the file. Of course, the same program may write and read (or even delete) the file. Deleting vdisk from your directory allows you to start a simulated disk from scratch. One of the challenges in building LLFS is to design and implement the set of data structures that map file names onto disk blocks. For this mapping, you will use a per file inode. Inodes map a file (a collection of bytes) to the disk representation of a file (a collection of disk blocks). Inodes thus contain what is referred to as the file’s metadata, and as such contain mappings to disk blocks, or to indirect blocks. More on indirect blocks later in class. Another challenge is be able to allocate blocks correctly. You need to track unused or free blocks. For this you can use a simple data structure, such as a bit map, which just tracks which blocks are allocated, and which are free. Another challenge will be to organize the naming structure into a directory tree. Directories aremappings of names to inodes for all files and directories contained within the directory. This might not seem like much of a challenge in itself, but handling this data structure in a way that makes LLFS robust requires some thought. An interesting feature of these data structures is that they requires persistence (meaning they has to be stored on disk, as well as being manipulated in memory). The issue of making LLFS robust revolves around making an effort to keep their on disk copies up to date so that, if the system crashes, they will survive the crash without becoming inconsistent (that is, without misplacing any blocks, or having allocated blocks showing up as free, etc).