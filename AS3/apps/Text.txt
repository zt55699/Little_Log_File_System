LLFS: The Little Log File SystemGoals of this assignment1. Manipulate a simulated disk, and format that disk with your version of the Little Log FileSystem (LLFS) [20 marks].2. Modify LLFS to support:a. reading and writing of files in the root directory [20 marks]b. creation of sub-directories [10 marks]c. reading and writing of files in any directory [15 marks]d. deletion of files and directories [10 marks]3. Make LLFS robust, so that the file system is less likely to be corrupted if the machine itis running on crashes [15 marks].4. Submit test files used to exercise functionality [10 marks].Specifics of the codeIn a directory called /disk, you will create a virtual disk environment, and in a directory called/io, you will create a program called File.c. This will be the basis for your filesystem.Goal 1: Create and manipulate the simulated disk, and format that disk with your versionof the Little Log File System (LLFS).Here, you will need to think about how blocks are read from and written to a disk, in one-blockchunks, and how disks are created and file systems mounted.Some Specifications for LLFS on disk:Disk parameters· Size of a block: 512 bytes· Number of blocks on disk: 4096· Name of file simulating disk: “vdisk” in current directory· Blocks are numbered from 0 to 4095Block 0 – superblock· Contains information about the filesystem implementation, such as· first 4 bytes: magic number· next 4 bytes: number of blocks on disk· next 4 bytes: number of inodes for diskBlock 1 – free block vector· With 512 bytes in this block, and 8 bits per byte, our free-block vector may hold 4096 bits.· First ten blocks (0 through 9) are not available for data.· To indicate an available block, bit must be set to 1.Other Blocks· You can reserve other blocks for other persistent data structures in LLFS· One thing to consider is how you are going to keep track of there all the inodes in thefilesystem.· Each inode has a unique id number.· Each inode is 32 bytes long.· An inode has to be allocated to represent information for the root directory.Goal 2: Modify the system to support basic LLFS functionality.The first challenge is to create a file (i.e., opening a file for “write access” that does not exist in adirectory is the same as creating file) and then to ensure bytes are written to correctly regardlessif they are within a block or span blocks. Converting from file position to a block and offset isuse division and modulo arithmetic.Basic steps you need to take to create a file include allocating and initializing an inode for thefile, writing the mapping between the inode and the file name in the directory, and making thisinformation persistent.Writing to a file in LLFS thus requires loading the file’s associated inode into memory,allocating disk blocks (marking them as allocated in the freelist), modifying the file’sinode to point to these blocks, and writing the data to these blocks. Releasing inodes involvesremoving pointers to the disk blocks from the inode, and marking the disk blocks as free.Modifying directories is very similar. Directories are just files with a specific format. Tokeep things simple, we will limit the depth in LLFS to 4.